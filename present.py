from flask import Flask, render_template, request, redirect, url_for
from pymongo import MongoClient
import imaplib
import email
from email.header import decode_header
import google.generativeai as genai
from dotenv import load_dotenv
import os
import nltk
import re
from nltk.tokenize import sent_tokenize, word_tokenize
from nltk.tag import pos_tag


# Configure Gemini API
genai.configure(api_key="AIzaSyDuyeP_WTzAPn0-f8i5TgD8xoCwbRiBlIY")

# MongoDB configuration
client = MongoClient("mongodb://localhost:27017/")
db = client["email_data"]
collection = db["emails"]

# Initialize Flask app
app = Flask(__name__)

# Define Email class
class Email:
    def __init__(self, email_body):
        self.email_body = email_body
    
    def retrieve_email_body(self):
        return self.email_body
def summarize_and_identify_action_items(email_body):
    # Start a chat with the Generative AI model
    chat = genai.GenerativeModel("gemini-pro").start_chat()
    
    # Send the email body as input to the AI model
    val = email_body + '''\n give a summary of the email sorting out important things like if its a meeting \n
    date: \n time\n venue\n attendees \n meet pertaining to \n
    if its a deadline say for what and why and by when
    '''
    response = chat.send_message(val)
    
    # Get the summary generated by the AI model
    summary = response.text
    
    # Implement logic to identify action items like schedules and deadlines
    action_items = []  # Placeholder, implement your logic here
    
    # Process the entire email body to identify action items
    # Tokenize the text into sentences
    sentences = sent_tokenize(email_body)

     #Define regular expressions to extract date, time, venue, and purpose
    date_regex = r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b'
    time_regex = r'\b(?:[0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]\s*(?:AM|PM|am|pm)?\b'
    venue_regex = r'\bin\b\s+([^\.,\n]+)'
    purpose_regex = r'\b(?:meet|meeting)\b'

    # Process each sentence to identify tasks
    for sentence in sentences:
        # Extract date, time, venue, and purpose from the sentence
        dates = re.findall(date_regex, sentence.lower())
        times = re.findall(time_regex, sentence)
        venues = re.findall(venue_regex, sentence, re.IGNORECASE)
        purposes = re.findall(purpose_regex, sentence.lower())

        # If date, time, and purpose are found, it's likely a task
        if dates and times and purposes:
            # Save the task details
            task_details = {
                "date": dates[0],
                "time": times[0],
                "venue": venues[0] if venues else None,
                "purpose": purposes[0]
            }
            action_items.append(task_details)

    return summary, action_items

def fetch_emails(username, password):
    # Connect to Gmail's IMAP server
    imap = imaplib.IMAP4_SSL("imap.gmail.com")
    imap.login(username, password)
    imap.select("inbox")

    # Search for unread emails
    result, data = imap.search(None, "UNSEEN")
    email_ids = data[0].split()

    # Fetch email bodies for each unread email
    for email_id in email_ids:
        result, data = imap.fetch(email_id, "(RFC822)")
        raw_email = data[0][1]
        msg = email.message_from_bytes(raw_email)

        # Extract email body
        body = ""
        if msg.is_multipart():
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    body += part.get_payload(decode=True).decode("utf-8", errors="ignore")
        else:
            body = msg.get_payload(decode=True).decode("utf-8", errors="ignore")

        # Summarize email body and identify action items
        summary, action_items = summarize_and_identify_action_items(body)

        # Save email and identified tasks to MongoDB
        email_data = {
            "subject": msg["Subject"],
            "from": msg["From"],
            "body": summary,
            "action_items": action_items,
            "unread": True,
        }
        collection.insert_one(email_data)

        # Mark email as read
        imap.store(email_id, "+FLAGS", "\\Seen")
    #db.collection.remove()
    # Close the connection
    imap.close()
    imap.logout()

@app.route("/")
def index():
    return redirect(url_for("login"))

@app.route("/login")
def login():
    return render_template("login.html")

@app.route("/submit", methods=["POST"])
def submit():
    if request.method == "POST":
        email = request.form["email"]
        password = request.form["password"]

        # Fetch emails
        fetch_emails(email, password)

        return redirect(url_for("dashboard"))
    else:
        return "Method Not Allowed", 405

@app.route("/dashboard")
def dashboard():
    try:
        # Fetch only unread emails from MongoDB and convert to a list
        unread_emails = list(collection.find({"unread": True}))

        # Render the dashboard template with the emails data
        return render_template("dashboard.html", emails=unread_emails)
    except Exception as e:
        # Log the error and render an error template or return a generic error message
        print(f"Error occurred: {e}")
        return "An error occurred while fetching data for the dashboard.", 500

if __name__ == "__main__":
    app.run(debug=True)
